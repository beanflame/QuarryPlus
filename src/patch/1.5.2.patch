--- a/com/yogpc/qp/bc/RefineryRecipeHelper.java
+++ b/com/yogpc/qp/bc/RefineryRecipeHelper.java
@@ -41,7 +41,7 @@
   public static void get(final TileRefinery tr) {
     if (tr.cached != null)
       return;
-    for (final RefineryRecipe ifr : RefineryRecipe.getRecipes()) {
+    for (final RefineryRecipe ifr : (java.util.Collection<RefineryRecipe>)RefineryRecipe.getRecipes()) {
       if (!craft(ifr, tr, false) || !RefineryRecipeHelper.check(ifr.result, tr))
         continue;
       craft(ifr, tr, true);
--- a/com/yogpc/qp/block/BlockController.java
+++ b/com/yogpc/qp/block/BlockController.java
@@ -35,15 +35,20 @@
 
 import cpw.mods.fml.common.FMLCommonHandler;
 
-public class BlockController extends Block implements IDismantleable {
+public class BlockController extends Block {
   public BlockController(final int id) {
     super(id, Material.circuits);
     setUnlocalizedName("spawnercontroller");
-    setTextureName("yogpstop_qp:spawnctl");
     setHardness(1.0f);
     setCreativeTab(QuarryPlusI.ct);
   }
 
+  @Override
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.blockIcon = ir.registerIcon("yogpstop_qp:spawnctl");
+  }
+
   private static final MobSpawnerBaseLogic getSpawner(final World w, final int x, final int y,
       final int z) {
     for (final ForgeDirection d : ForgeDirection.VALID_DIRECTIONS) {
@@ -138,28 +143,4 @@
     } else if (!r && m == 1)
       w.setBlockMetadataWithNotify(x, y, z, 0, 4);
   }
-
-  @Override
-  public boolean canDismantle(final EntityPlayer arg0, final World arg1, final int arg2,
-      final int arg3, final int arg4) {
-    return true;
-  }
-
-  @Override
-  public ItemStack dismantleBlock(final EntityPlayer e, final World w, final int x,
-      final int y, final int z, final boolean toinv) {
-    int m = w.getBlockMetadata(x, y, z);
-    final ItemStack ret = new ItemStack(idDropped(m, w.rand, 0), quantityDropped(m, 0, w.rand), damageDropped(m));
-    w.setBlockToAir(x, y, z);
-    if (!toinv) {
-        final float f = 0.7F;
-        final double d0 = w.rand.nextFloat() * f + (1.0F - f) * 0.5D;
-        final double d1 = w.rand.nextFloat() * f + (1.0F - f) * 0.5D;
-        final double d2 = w.rand.nextFloat() * f + (1.0F - f) * 0.5D;
-        final EntityItem entityitem = new EntityItem(w, x + d0, y + d1, z + d2, ret);
-        entityitem.delayBeforeCanPickup = 10;
-        w.spawnEntityInWorld(entityitem);
-      }
-    return ret;
-  }
 }
--- a/com/yogpc/qp/block/BlockFrame.java
+++ b/com/yogpc/qp/block/BlockFrame.java
@@ -27,7 +27,12 @@
     setHardness(0.5F);
     setTickRandomly(true);
     setUnlocalizedName("qpFrame");
-    setTextureName("yogpstop_qp:blockFrame");
+  }
+
+  @Override
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.blockIcon = ir.registerIcon("yogpstop_qp:blockFrame");
   }
 
   @Override
--- a/com/yogpc/qp/block/BlockMover.java
+++ b/com/yogpc/qp/block/BlockMover.java
@@ -29,7 +29,7 @@
 import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
 
-public class BlockMover extends Block implements IDismantleable {
+public class BlockMover extends Block {
   Icon textureTop, textureBottom;
 
   public BlockMover(final int id) {
@@ -68,28 +68,4 @@
       e.openGui(QuarryPlus.I, QuarryPlusI.guiIdMover, w, x, y, z);
     return true;
   }
-
-  @Override
-  public boolean canDismantle(final EntityPlayer arg0, final World arg1, final int arg2,
-      final int arg3, final int arg4) {
-    return true;
-  }
-
-  @Override
-  public ItemStack dismantleBlock(final EntityPlayer e, final World w, final int x,
-      final int y, final int z, final boolean toinv) {
-    int m = w.getBlockMetadata(x, y, z);
-    final ItemStack ret = new ItemStack(idDropped(m, w.rand, 0), quantityDropped(m, 0, w.rand), damageDropped(m));
-    w.setBlockToAir(x, y, z);
-    if (!toinv) {
-        final float f = 0.7F;
-        final double d0 = w.rand.nextFloat() * f + (1.0F - f) * 0.5D;
-        final double d1 = w.rand.nextFloat() * f + (1.0F - f) * 0.5D;
-        final double d2 = w.rand.nextFloat() * f + (1.0F - f) * 0.5D;
-        final EntityItem entityitem = new EntityItem(w, x + d0, y + d1, z + d2, ret);
-        entityitem.delayBeforeCanPickup = 10;
-        w.spawnEntityInWorld(entityitem);
-      }
-    return ret;
-  }
 }
--- a/com/yogpc/qp/block/BlockPlainPipe.java
+++ b/com/yogpc/qp/block/BlockPlainPipe.java
@@ -18,7 +18,12 @@
     this.maxY = 1.0;
     this.maxZ = 0.75;
     setUnlocalizedName("qpPlainPipe");
-    setTextureName("yogpstop_qp:blockPlainPipe");
+  }
+
+  @Override
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.blockIcon = ir.registerIcon("yogpstop_qp:blockPlainPipe");
   }
 
   @Override
--- a/com/yogpc/qp/block/BlockRefinery.java
+++ b/com/yogpc/qp/block/BlockRefinery.java
@@ -46,7 +46,12 @@
     setHardness(5F);
     setCreativeTab(QuarryPlusI.ct);
     setUnlocalizedName("RefineryPlus");
-    setTextureName("yogpstop_qp:refineryDummy");
+  }
+
+  @Override
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.blockIcon = ir.registerIcon("yogpstop_qp:refineryDummy");
   }
 
   @Override
@@ -107,7 +112,7 @@
   private static boolean fill(final ITankContainer tank, final ForgeDirection side,
       final EntityPlayer player) {
     final ItemStack current = player.getCurrentEquippedItem();
-    final LiquidStack liquid = LiquidContainerRegistry.getFluidForFilledItem(current);
+    final LiquidStack liquid = LiquidContainerRegistry.getLiquidForFilledItem(current);
     if (liquid != null) {
       final int used = tank.fill(side, liquid, true);
       if (used > 0) {
--- a/com/yogpc/qp/block/BlockWorkbench.java
+++ b/com/yogpc/qp/block/BlockWorkbench.java
@@ -25,7 +25,12 @@
     setHardness(3F);
     setCreativeTab(QuarryPlusI.ct);
     setUnlocalizedName("WorkbenchPlus");
-    setTextureName("yogpstop_qp:workbench");
+  }
+
+  @Override
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.blockIcon = ir.registerIcon("yogpstop_qp:workbench");
   }
 
   @Override
--- a/com/yogpc/qp/gui/GuiP_List.java
+++ b/com/yogpc/qp/gui/GuiP_List.java
@@ -91,9 +91,7 @@
         this.mc.displayGuiScreen(new GuiP_SelectSide(this.tile, this, par1.id == -5));
         break;
       case PacketHandler.CtS_REMOVE_MAPPING:
-        String name = this.tile.mapping[this.dir].get(this.oreslot.currentore);
-        if (LiquidDictionary.isFluidRegistered(name))
-          name = LiquidDictionary.getFluid(name).getLocalizedName();
+        final String name = this.tile.mapping[this.dir].get(this.oreslot.currentore);
         this.mc.displayGuiScreen(new GuiYesNo(this, StatCollector
             .translateToLocal("tof.deletefluidsure"), name, par1.id));
         break;
--- a/com/yogpc/qp/gui/GuiP_Manual.java
+++ b/com/yogpc/qp/gui/GuiP_Manual.java
@@ -51,18 +51,14 @@
   public void actionPerformed(final GuiButton par1) {
     switch (par1.id) {
       case -1:
-        String name = this.blockid.getText();
+        final String name = this.blockid.getText();
         if (name.length() == 0)
           return;
         if (this.tile.mapping[this.targetid].contains(name)) {
-          if (LiquidDictionary.isFluidRegistered(name))
-            name = LiquidDictionary.getFluid(name).getLocalizedName();
           this.mc.displayGuiScreen(new GuiError(this, StatCollector
               .translateToLocal("tof.alreadyerror"), name));
           return;
         }
-        if (LiquidDictionary.isFluidRegistered(name))
-          name = LiquidDictionary.getFluid(name).getLocalizedName();
         this.mc.displayGuiScreen(new GuiYesNo(this, StatCollector
             .translateToLocal("tof.addfluidsure"), name, -1));
         break;
--- a/com/yogpc/qp/gui/GuiP_SlotBlockList.java
+++ b/com/yogpc/qp/gui/GuiP_SlotBlockList.java
@@ -73,7 +73,7 @@
 
   @Override
   protected void drawSlot(final int i, final int v2, final int v3, final int v4, final Tessellator t) {
-    final String name = LiquidDictionary.getFluid(this.blocklist.get(i)).getLocalizedName();
+    final String name = this.blocklist.get(i);
     Minecraft.getMinecraft().fontRenderer.drawStringWithShadow(name,
         (this.parent.width - Minecraft.getMinecraft().fontRenderer.getStringWidth(name)) / 2,
         v3 + 2, 0xFFFFFF);
--- a/com/yogpc/qp/gui/GuiP_SlotList.java
+++ b/com/yogpc/qp/gui/GuiP_SlotList.java
@@ -57,9 +57,7 @@
 
   @Override
   protected void drawSlot(final int i, final int v2, final int v3, final int v4, final Tessellator t) {
-    String name = this.target.get(i);
-    if (LiquidDictionary.isFluidRegistered(name))
-      name = LiquidDictionary.getFluid(name).getLocalizedName();
+    final String name = this.target.get(i);
     Minecraft.getMinecraft().fontRenderer
         .drawStringWithShadow(
             name,
--- a/com/yogpc/qp/InvUtils.java
+++ b/com/yogpc/qp/InvUtils.java
@@ -100,11 +100,10 @@
         pi.add((IInventory) t);
         pid.add(d.getOpposite());
       }
-      if (t instanceof IPipeTile) {
-        final IPipeTile p = (IPipeTile) t;
-        if (p.getPipeType() != IPipeTile.PipeType.ITEM || !p.isPipeConnected(d.getOpposite()))
+      if (t instanceof IPipeEntry && ((IPipeEntry)t).acceptItems()) {
+        if (t instanceof IPipeConnection && !((IPipeConnection) t).isPipeConnected(d.getOpposite()))
           continue;
-        pp.add(p);
+        pp.add(t);
         ppd.add(d.getOpposite());
       }
     }
@@ -113,10 +112,11 @@
       if (is.stackSize <= 0)
         return;
     }
-    for (int i = 0; i < pp.size(); i++) {
-      is.stackSize -= ((IPipeTile) pp.get(i)).injectItem(is, true, ppd.get(i));
-      if (is.stackSize <= 0)
-        return;
+    if (pp.size() > 0) {
+      final int i = w.rand.nextInt(pp.size());
+      ((IPipeEntry) pp.get(i)).entityEntering(is.copy(), ppd.get(i));
+      is.stackSize = 0;
+      return;
     }
   }
 }
--- a/com/yogpc/qp/item/ItemArmorElectric.java
+++ b/com/yogpc/qp/item/ItemArmorElectric.java
@@ -29,22 +29,26 @@
 import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
 
-public class ItemArmorElectric extends ItemArmor implements ISpecialArmor, IElectricItem,
-    IEnergyContainerItem {
+public class ItemArmorElectric extends ItemArmor implements ISpecialArmor, IElectricItem {
   public ItemArmorElectric(final int id) {
     super(id, EnumHelper.addArmorMaterial("ELECTRIC", 33, new int[] {3, 8, 6, 3}, 0), QuarryPlus.proxy
         .addNewArmourRendererPrefix("electric"), 1);
     setUnlocalizedName("electric_armor");
     setCreativeTab(CreativeTabs.tabCombat);
-    setTextureName("yogpstop_qp:elecArmor");
     setMaxDamage(100);
     setMaxStackSize(1);
     setCreativeTab(QuarryPlusI.ct);
   }
 
   @Override
-  public String getArmorTexture(final ItemStack i, final Entity e, final int s, final String t) {
-    return "yogpstop_qp:textures/models/armor/elecArmor_layer_1.png";
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.itemIcon = ir.registerIcon("yogpstop_qp:elecArmor");
+  }
+
+  @Override
+  public String getArmorTexture(final ItemStack i, final Entity e, final int s, final int l) {
+    return "/mods/yogpstop_qp/textures/models/armor/elecArmor_layer_1.png";
   }
 
   private static final double maxFallSpeedOnHover = 0.35;
@@ -192,25 +196,4 @@
   public int getTransferLimit(final ItemStack itemStack) {
     return 2500;
   }
-
-  @Override
-  public int extractEnergy(final ItemStack is, final int am, final boolean sim) {
-    return 0;
-  }
-
-  @Override
-  public int getEnergyStored(final ItemStack is) {
-    return (int) (ElectricItemManager.getCharge(is) * 4);
-  }
-
-  @Override
-  public int getMaxEnergyStored(final ItemStack is) {
-    return getMaxCharge(is) * 4;
-  }
-
-  @Override
-  public int receiveEnergy(final ItemStack is, final int am, final boolean sim) {
-    return (int) (ElectricItemManager.charge(is, Math.min((double) am / 4, getTransferLimit(is)),
-        getMaxCharge(is)) * 4);
-  }
 }
--- a/com/yogpc/qp/item/ItemMirror.java
+++ b/com/yogpc/qp/item/ItemMirror.java
@@ -21,11 +21,16 @@
   public ItemMirror(final int id) {
     super(id);
     setUnlocalizedName("magicmirror");
-    setTextureName("yogpstop_qp:mm");
     setCreativeTab(QuarryPlusI.ct);
   }
 
   @Override
+  @SideOnly(Side.CLIENT)
+  public void registerIcons(final IconRegister ir) {
+    this.itemIcon = ir.registerIcon("yogpstop_qp:mm");
+  }
+
+  @Override
   public ItemStack onEaten(final ItemStack i, final World w, final EntityPlayer p) {
     if (p instanceof EntityPlayerMP) {
       if (i.getItemDamage() == 2) {
--- a/com/yogpc/qp/nei/QuarryPlusUsageHandler.java
+++ b/com/yogpc/qp/nei/QuarryPlusUsageHandler.java
@@ -32,7 +32,7 @@
 
   @Override
   public String getGuiTexture() {
-    return "nei:textures/gui/recipebg.png";
+    return "/codechicken/nei/recipebg.png";
   }
 
   @Override
--- a/com/yogpc/qp/nei/WBPRecipeHandler.java
+++ b/com/yogpc/qp/nei/WBPRecipeHandler.java
@@ -62,7 +62,7 @@
 
   @Override
   public String getGuiTexture() {
-    return "yogpstop_qp:textures/gui/workbench.png";
+    return "/mods/yogpstop_qp/textures/gui/workbench.png";
   }
 
   @Override
@@ -76,10 +76,10 @@
   }
 
   @Override
-  public void drawBackground(final int recipe) {
+  public void drawBackground(final GuiContainerManager gui, final int recipe) {
     GL11.glColor4f(1, 1, 1, 1);
-    GuiDraw.changeTexture(getGuiTexture());
-    GuiDraw.drawTexturedModalRect(0, 0, 5, 11, 166, 121);
+    gui.bindTexture(getGuiTexture());
+    gui.drawTexturedModalRect(0, 0, 5, 11, 166, 121);
   }
 
   @Override
--- a/com/yogpc/qp/QuarryPlus.java
+++ b/com/yogpc/qp/QuarryPlus.java
@@ -33,12 +33,12 @@
   @Mod.Instance("QuarryPlus")
   public static QuarryPlus I;
 
-  @Mod.EventHandler
+  @Mod.PreInit
   public void preInit(final FMLPreInitializationEvent event) {
     QuarryPlusI.preInit(event);
   }
 
-  @Mod.EventHandler
+  @Mod.Init
   public void init(final FMLInitializationEvent event) {
     QuarryPlusI.init();
   }
--- a/com/yogpc/qp/QuarryPlusI.java
+++ b/com/yogpc/qp/QuarryPlusI.java
@@ -120,7 +120,7 @@
   @ForgeSubscribe
   @SideOnly(Side.CLIENT)
   public void loadTextures(final TextureStitchEvent.Pre evt) {
-    if (evt.map.getTextureType() == 0) {
+    if (evt.map.textureType == 0) {
       final TextureMap map = evt.map;
       RenderEntityLaser.icons = new Icon[4];
       RenderEntityLaser.icons[EntityLaser.DRILL] =
@@ -134,7 +134,7 @@
     }
   }
 
-  private static final Pattern lang = Pattern.compile("assets/(.*)/lang/(.*)\\.lang");
+  private static final Pattern lang = Pattern.compile("mods/(.*)/lang/(.*)\\.lang");
   private static final Pattern format = Pattern.compile("%(\\d+\\$)?[\\d\\.]*[df]");
 
   public static Properties parseLangFile(final InputStream is, final boolean cl) {
--- a/com/yogpc/qp/render/RenderEntityLaser.java
+++ b/com/yogpc/qp/render/RenderEntityLaser.java
@@ -23,11 +23,6 @@
   private RenderEntityLaser() {}
 
   @Override
-  protected String getEntityTexture(final Entity entity) {
-    return TextureMap.locationBlocksTexture;
-  }
-
-  @Override
   public void doRender(final Entity e, final double i, final double j, final double k,
       final float f, final float f1) {
     if (e.isDead)
@@ -56,7 +51,7 @@
       final double k, final double iSize, final double jSize, final double kSize, final int tex) {
     GL11.glPushMatrix();
     GL11.glTranslated(i, j, k);
-    tm.bindTexture(TextureMap.locationBlocksTexture);
+    tm.bindTexture("/terrain.png");
     final Tessellator t = Tessellator.instance;
     final RenderBlocks rb = new RenderBlocks();
     for (int iBase = 0; iBase < iSize; ++iBase)
--- a/com/yogpc/qp/render/RenderRefinery.java
+++ b/com/yogpc/qp/render/RenderRefinery.java
@@ -111,7 +111,7 @@
 
     GL11.glRotatef(angle, 0, 1, 0);
 
-    bindTexture(TEXTURE);
+    bindTextureByName(TEXTURE);
 
     GL11.glPushMatrix();
     GL11.glTranslatef(-0.5F, -0.5F, -0.5F);
@@ -178,8 +178,9 @@
           GL11.glPushMatrix();
           GL11.glTranslatef(tx, ty, tz);
         }
-        bindTexture(TextureMap.locationBlocksTexture);
-        setColor(liquid.getFluid().getColor(liquid));
+        bindTextureByName(liquid.getTextureSheet());
+        final ItemStack stack = liquid.asItemStack();
+        setColor(stack.getItem().getColorFromItemStack(stack, 0));
         GL11.glCallList(list[(int) (liquid.amount / buf * 99)]);
         if (tx != 0 || ty != 0 || tz != 0)
           GL11.glPopMatrix();
@@ -187,25 +188,22 @@
     }
   }
 
-  private static final Map<Fluid, int[]> stillRenderCache = new HashMap<Fluid, int[]>();
+  private static final Map<LiquidStack, int[]> stillRenderCache = new HashMap<LiquidStack, int[]>();
 
   private static int[] getLiquidDisplayLists(final LiquidStack fluidStack) {
-    final Fluid fluid = fluidStack.getFluid();
-    if (fluid == null)
-      return null;
-    final Map<Fluid, int[]> cache = stillRenderCache;
-    int[] diplayLists = cache.get(fluid);
+    final Map<LiquidStack, int[]> cache = stillRenderCache;
+    int[] diplayLists = cache.get(fluidStack);
     if (diplayLists != null)
       return diplayLists;
     diplayLists = new int[100];
     Block baseBlock;
     Icon texture;
-    if (fluid.getBlockID() > -1) {
-      baseBlock = Block.blocksList[fluid.getBlockID()];
-      texture = fluid.getStillIcon();
+    if (fluidStack.itemID > -1) {
+      baseBlock = Block.blocksList[fluidStack.itemID];
+      texture = fluidStack.getRenderingIcon();
     } else {
       baseBlock = Block.waterStill;
-      texture = fluid.getStillIcon();
+      texture = fluidStack.getRenderingIcon();
     }
     GL11.glDisable(GL11.GL_LIGHTING);
     GL11.glDisable(GL11.GL_BLEND);
@@ -235,7 +233,7 @@
     GL11.glEnable(GL11.GL_CULL_FACE);
     GL11.glEnable(GL11.GL_BLEND);
     GL11.glEnable(GL11.GL_LIGHTING);
-    cache.put(fluid, diplayLists);
+    cache.put(fluidStack, diplayLists);
     return diplayLists;
   }
 
--- a/com/yogpc/qp/tile/APowerTile.java
+++ b/com/yogpc/qp/tile/APowerTile.java
@@ -12,9 +12,10 @@
 import net.minecraftforge.common.MinecraftForge;
 import net.minecraftforge.common.ForgeDirection;
 
-public abstract class APowerTile extends APacketTile implements IEnergyHandler, IEnergySink,
-    IPowerReceptor {
-  private final IPowerProvider pp = new IPowerProvider(this, Type.MACHINE);
+public abstract class APowerTile extends APacketTile implements IEnergySink, IPowerReceptor {
+  private final IPowerProvider pp =
+      PowerFramework.currentFramework != null ? PowerFramework.currentFramework
+          .createPowerProvider() : null;
   private double all, maxGot, max, got;
   private boolean ic2ok = false;
 
@@ -25,8 +26,10 @@
       MinecraftForge.EVENT_BUS.post(new EnergyTileLoadEvent(this));
       this.ic2ok = true;
     }
+    if (this.pp != null) {
     final double rem = Math.min(this.maxGot - this.got, this.max - this.all - this.got);
     this.got += this.pp.useEnergy(0, (float) rem, true);
+    }
     this.all += this.got;
     this.got = 0;
   }
@@ -52,7 +55,8 @@
     this.all = nbttc.getDouble("storedEnergy");
     this.max = nbttc.getDouble("MAX_stored");
     this.maxGot = nbttc.getDouble("MAX_receive");
-    this.pp.configure(0, (float) this.maxGot, 0, (float) this.max);
+    if (this.pp != null)
+      this.pp.configure(0, 0, (int) this.maxGot, 0, (int) this.max);
   }
 
   @Override
@@ -97,32 +101,18 @@
   public final void configure(final double x, final double maxstored) {
     this.maxGot = x;
     this.max = maxstored;
-    this.pp.configure(0, (float) this.maxGot, 0, (float) this.max);
-  }
-
-  @Override
-  public final int getEnergyStored(final ForgeDirection d) {
-    return (int) (this.all * 10);
-  }
-
-  @Override
-  public final int getMaxEnergyStored(final ForgeDirection d) {
-    return (int) (this.max * 10);
-  }
-
-  @Override
-  public final int receiveEnergy(final ForgeDirection d, final int am, final boolean sim) {
-    return (int) getEnergy((double) am / 10, !sim) * 10;
+    if (this.pp != null)
+      this.pp.configure(0, 0, (int) this.maxGot, 0, (int) this.max);
   }
 
   @Override
   public final int demandsEnergy() {
-    return Math.min(this.maxGot - this.got, this.max - this.all - this.got) * 2.5;
+    return (int) (Math.min(this.maxGot - this.got, this.max - this.all - this.got) * 2.5);
   }
 
   @Override
   public final int injectEnergy(final Direction d, final int am) {
-    return am - getEnergy(am / 2.5, true) * 2.5;
+    return (int) (am - getEnergy(am / 2.5, true) * 2.5);
   }
 
   @Override
@@ -131,11 +121,6 @@
   }
 
   @Override
-  public final int extractEnergy(final ForgeDirection d, final int am, final boolean sim) {
-    return 0;
-  }
-
-  @Override
   public final boolean isAddedToEnergyNet() {
     return true;
   }
@@ -154,8 +139,13 @@
   public final void doWork() {}
 
   @Override
-  public final World getWorld() {
-    return this.worldObj;
+  public final int powerRequest(final ForgeDirection d) {
+    return (int) Math.ceil(Math.min(this.maxGot, this.max - this.all));
+  }
+
+  @Override
+  public final void setPowerProvider(final IPowerProvider p) {
+    return;
   }
 
 }
--- a/com/yogpc/qp/tile/TilePump.java
+++ b/com/yogpc/qp/tile/TilePump.java
@@ -142,7 +142,7 @@
               this.zCoord + fd.offsetZ);
       if (te instanceof ITankContainer)
         for (final String s : this.mapping[fd.ordinal()]) {
-          pZ = this.liquids.indexOf(LiquidDictionary.getLiquidStack(s, 0));
+          pZ = this.liquids.indexOf(LiquidDictionary.getCanonicalLiquid(s));
           if (pZ == -1)
             continue;
           fs = this.liquids.get(pZ);
@@ -526,8 +526,8 @@
       for (int i = 0; i < this.liquids.size(); i++) {
         final LiquidStack s = this.liquids.get(i);
         ret[i + 1] =
-            StatCollector.translateToLocalFormatted("yog.pump.liquid", StatCollector.translateToLocal(s
-                .getFluid().getUnlocalizedName()), Integer.toString(s.amount));
+            StatCollector.translateToLocalFormatted("yog.pump.liquid", LiquidDictionary.findLiquidName(s)
+                , Integer.toString(s.amount));
       }
     } else
       ret[0] = StatCollector.translateToLocal("chat.pumpcontainno");
@@ -540,6 +540,10 @@
   }
 
   @Override
+  public LiquidStack drain(final int id, final int maxDrain, final boolean doDrain) {
+    return null;// TODO
+  }
+
   public LiquidStack drain(final ForgeDirection fd, final LiquidStack resource, final boolean doDrain) {
     if (resource == null)
       return null;
@@ -561,13 +565,8 @@
   }
 
   @Override
-  public boolean canFill(final ForgeDirection from, final Fluid fluid) {
-    return false;
-  }
-
-  @Override
-  public boolean canDrain(final ForgeDirection from, final Fluid fluid) {
-    return true;
+  public int fill(final int id, final LiquidStack resource, final boolean doFill) {
+    return 0;
   }
 
   @Override
@@ -577,8 +576,8 @@
     final LinkedList<LiquidTank> ret = new LinkedList<LiquidTank>();
     if (this.mapping[fd.ordinal()].size() <= 0) {
       if (this.liquids.size() <= 0)
-        for (final Integer i : LiquidDictionary.getLiquids().values())
-          ret.add(new LiquidTank(new LiquidStack(i.intValue(), 0), Integer.MAX_VALUE));
+        for (final LiquidStack i : LiquidDictionary.getLiquids().values())
+          ret.add(new LiquidTank(i, Integer.MAX_VALUE));
       else
         for (final LiquidStack fs : this.liquids)
           ret.add(new LiquidTank(fs, Integer.MAX_VALUE));
@@ -586,7 +585,7 @@
       int index;
       LiquidStack fs;
       for (final String s : this.mapping[fd.ordinal()]) {
-        fs = LiquidDictionary.getLiquidStack(s, 0);
+        fs = LiquidDictionary.getCanonicalLiquid(s);
         if (fs == null)
           continue;
         index = this.liquids.indexOf(fs);
@@ -600,6 +599,16 @@
   }
 
   @Override
+  public ILiquidTank getTank(final ForgeDirection d, final LiquidStack t) {
+    final ILiquidTank[] ilda = getTanks(d);
+    if (ilda == null) return null;
+    if (t == null) return ilda[0];
+    for (final ILiquidTank ild : ilda)
+      if (ild.getLiquid().isLiquidEqual(t)) return ild;
+    return null;
+  }
+
+  @Override
   public LiquidStack drain(final ForgeDirection fd, final int maxDrain, final boolean doDrain) {
     if (fd.ordinal() < 0 || fd.ordinal() >= this.mapping.length)
       return drain(ForgeDirection.UP, maxDrain, doDrain);
@@ -611,7 +620,7 @@
     int index;
     LiquidStack fs;
     for (final String s : this.mapping[fd.ordinal()]) {
-      fs = LiquidDictionary.getLiquidStack(s, maxDrain);
+      fs = LiquidDictionary.getLiquid(s, maxDrain);
       if (fs == null)
         continue;
       index = this.liquids.indexOf(fs);
@@ -634,7 +643,7 @@
   static final boolean isLiquid(final Block b, final boolean s, final World w, final int x,
       final int y, final int z, final int m) {
     if (b instanceof ILiquid)
-      return !s || ((ILiquid) b).canDrain(w, x, y, z);
+      return !s || ((ILiquid) b).stillLiquidMeta() == m;
     if (b == Block.waterStill || b == Block.waterMoving || b == Block.lavaStill
         || b == Block.lavaMoving)
       return !s || m == 0;
@@ -650,15 +659,12 @@
     if (isLiquid(b, false, null, 0, 0, 0, 0)) {
       LiquidStack fs = null;
       if (b instanceof ILiquid
-          && ((ILiquid) b).canDrain(this.worldObj, bx + this.xOffset, this.py, bz
-              + this.zOffset))
-        fs =
-            ((ILiquid) b).drain(this.worldObj, bx + this.xOffset, this.py, bz + this.zOffset,
-                true);
+          && ((ILiquid) b).stillLiquidMeta() == meta)
+        fs = new LiquidStack(((ILiquid) b).stillLiquidId(), LiquidContainerRegistry.BUCKET_VOLUME, ((ILiquid) b).stillLiquidMeta());
       else if ((b == Block.waterStill || b == Block.waterMoving) && meta == 0)
-        fs = new LiquidStack(LiquidDictionary.WATER, LiquidContainerRegistry.BUCKET_VOLUME);
+        fs = new LiquidStack(Block.waterStill, LiquidContainerRegistry.BUCKET_VOLUME);
       else if ((b == Block.lavaStill || b == Block.lavaMoving) && meta == 0)
-        fs = new LiquidStack(LiquidDictionary.LAVA, LiquidContainerRegistry.BUCKET_VOLUME);
+        fs = new LiquidStack(Block.lavaStill, LiquidContainerRegistry.BUCKET_VOLUME);
       if (fs != null) {
         final int index = this.liquids.indexOf(fs);
         if (index != -1)
--- a/com/yogpc/qp/tile/TileRefinery.java
+++ b/com/yogpc/qp/tile/TileRefinery.java
@@ -237,7 +237,6 @@
     return 0;
   }
 
-  @Override
   public LiquidStack drain(final ForgeDirection from, final LiquidStack resource,
       final boolean doDrain) {
     if (resource == null)
@@ -276,13 +275,13 @@
   }
 
   @Override
-  public boolean canFill(final ForgeDirection from, final Fluid fluid) {
-    return true;
+  public int fill(final int i, final LiquidStack f, final boolean d) {
+    return fill(ForgeDirection.UNKNOWN, f, d);
   }
 
   @Override
-  public boolean canDrain(final ForgeDirection from, final Fluid fluid) {
-    return true;
+  public LiquidStack drain(final int i, final int x, final boolean d) {
+    return drain(ForgeDirection.UNKNOWN, x, d);
   }
 
   @Override
@@ -295,6 +294,18 @@
   }
 
   @Override
+  public ILiquidTank getTank(final ForgeDirection direction, final LiquidStack type) {
+    if (type == null)
+      return null;
+    for (int i = this.src.length - 1; i >= 0; i--)
+      if (type.isLiquidEqual(this.src[i]))
+        return new LiquidTank(this.src[i], this.buf);
+    if (type.isLiquidEqual(this.res))
+      return new LiquidTank(this.res, this.buf);
+    return null;
+  }
+
+  @Override
   public Map<Integer, Byte> get() {
     final Map<Integer, Byte> ret = new HashMap<Integer, Byte>();
     if (this.efficiency > 0)
